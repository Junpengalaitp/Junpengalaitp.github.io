<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>R | API+: Programmers&#39; Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">R | API+<span id="projectnumber">&#160;Version 13.4.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('programmers_guide.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Programmers' Guide </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="pg_doc_info"></a>
Document Information</h1>
<p >This document and the Software Products that it describes are protected by copyright law and international treaties. Unauthorized use, reproduction or distribution of this document, or any portion of it, may result in severe civil and criminal penalties, and will be prosecuted to the maximum extent possible under the law.</p>
<p >The Software Products described in this document are licensed strictly in accordance with a separate Software System License Agreement, granted by Rithmic, LLC, which contains restrictions on use, reverse engineering, disclosure, confidentiality and other matters.</p>
<p >Information in this document, as well as the features and specifications of the Software Products described by this document, are subject to change without notice. Rithmic, LLC, makes no claims as to the accuracy or completeness of any information contained herein. Rithmic, LLC, is not responsible for any typographical errors contained in this document.</p>
<p >Copyright (c) 2024 Rithmic, LLC.</p>
<p >Rithmic&trade;, R | Trade Execution Platform&trade;, R | Trader&trade;, R | Trader Pro&trade;, R | Manager&trade;, R | API&trade;, R | API+&trade;, R | DiamondAPI&trade;, and R | API+.NET&trade; are trademarks of Rithmic, LLC, in the United States, other countries, or both.</p>
<hr  />
<h1><a class="anchor" id="pg_toc"></a>
Table Of Contents</h1>
<ul>
<li><a class="el" href="programmers_guide.html#pg_preface">Preface</a> </li>
<li><a class="el" href="programmers_guide.html#pg_what_is_rtrade">What is R | Trade Execution Platform?</a> </li>
<li><a class="el" href="programmers_guide.html#pg_what_is_rapi">What is R | API+?</a> </li>
<li><a class="el" href="programmers_guide.html#pg_os_platforms">Operating Systems, Frameworks, Compilers and Target Platforms</a> </li>
<li><a class="el" href="programmers_guide.html#pg_file_list">Installation and File List</a> </li>
<li><a class="el" href="programmers_guide.html#pg_building_cpp">Building A C++ Rithmic API Application</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_building_cpp_windows">Building C++ On Windows Using Visual Studio</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_building_cpp_linux">Building C++ On Linux Using GCC/g++</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_building_cpp_darwin">Building C++ On Darwin Using GCC/g++</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_building_dotnet">Building A .NET Rithmic API Application</a> </li>
<li><a class="el" href="programmers_guide.html#pg_classes">Organization Of Rithmic API Classes</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_class_categories">There are three main categories of classes in the Rithmic APIs :</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_class_dump_method">The dump() Method</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_configuring">Configuring A Rithmic API Application</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_configuring_configuration_files">Configuration Files</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_configuring_conformance">Conformance and Fees</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_max_session_count">Max Session Counts</a> </li>
<li><a class="el" href="programmers_guide.html#pg_plugins">Using R | Trader Pro as a Plug-In Host</a> </li>
<li><a class="el" href="programmers_guide.html#pg_environments">Connecting to Multiple Rithmic Systems Simultaneously Using Environments</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_environments_background">Background</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_environments_multiple_environments">Multiple Environments</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_environments_interface">Programming Interface</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_environments_single_environment">Prior Behavior With A Single Environment</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_environments_comments">Comments</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_connections">Connections</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_cnnct_pts">Connect Points</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_connection_aggregated_data">Aggregated Data Market Data</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_connection_locations">Gateways and Points-Of-Presence</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_connection_best_practices">Best Practices</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_connection_mgmt">Connection Management</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_updates_and_snapshots">Establishing And Maintaining State With The Snapshot-Update Pattern</a> </li>
<li><a class="el" href="programmers_guide.html#pg_strings_cpp">Strings And tsNCharcb (C++ Only)</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_strings_why_tsncharcb">Why use the tsNCharcb for representing strings?</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_strings_cpp_to_tsnchar">How does one convert a C++ string into a tsNCharcb?</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_strings_tsnchar_to_cpp">How does one convert a tsNCharcb into a C++ string?</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_strings_tsnchar_init">Do I need to initialize both the pData and the iDataLen of each tsNCharcb?</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_strings_memory">Who owns the memory pointed to by tsNCharcb::pData?</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_timestamps">On Timestamps (ssboe, usecs and nsecs)</a> </li>
<li><a class="el" href="programmers_guide.html#pg_threads">On Threads</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_threads_cpp">Threads In C++ API</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_threads_dotnet">Threads In .NET API</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_errors">Error Handling Conventions</a> <ul>
<li>
<a class="el" href="programmers_guide.html#pg_error_codes">Error Codes</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_exception_classes">Exception Classes</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_error_why">Why And Where Errors Might Occur</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_aicode_out_param">The 'aiCode' Out Parameter (C++ only)</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_error_examples">Examples Of Errors</a> </li>
<li>
<a class="el" href="programmers_guide.html#pg_errors_in_user_callbacks">Error Handling In User Implemented Callbacks</a> </li>
</ul>
</li>
<li><a class="el" href="programmers_guide.html#pg_basic_steps">Basic Steps of a Program that Incorporates R | API</a> </li>
<li><a class="el" href="programmers_guide.html#pg_bug_reports">Feedback And Bug Reports</a> </li>
<li><a class="el" href="programmers_guide.html#pg_contact_info">Contact Info</a></li>
</ul>
<hr  />
<h1><a class="anchor" id="pg_preface"></a>
Preface</h1>
<p >This Programmer's Guide is a high level description of R | API along with technical background information. It is intended for users new to Rithmic's APIs looking for a basic overview. For additional information please consult other resources, such as documentation for each class/method, sample code, and/or the FAQ.</p>
<p >Suggestions for improvement of this document are always welcome.</p>
<hr  />
<h1><a class="anchor" id="pg_what_is_rtrade"></a>
What is R | Trade Execution Platform?</h1>
<p >The R | Trade Execution Platform is software that implements a trading platform with market data, risk management and order handling functionality. There are many instances of the R | Trade Execution Platform. Each instance is referred to as a "system", or "environment". Some are private systems, and others exist under different brands, or are available through a particular FCM or broker.</p>
<p >Each of these systems appear as values in the "System" drop down box of the R | Trader login screen. Programmatically, one specifies different parameters to the REngine constructor to access different Rithmic systems.</p>
<p >Each of these systems serves a different purpose. For example,</p>
<p ><b>Rithmic Test :</b> The test environment is called Rithmic Test. Exchanges typically provide a test environment in which test orders are placed against a test matching engine, and resultant market data is published. This environment uses these test environments. This environment can appear strange because the market data can be unrealistic, and is often driven by what (test) orders are resting on the matching engine.</p>
<p ><b>Rithmic 01 :</b> There is a production environment called Rithmic 01 which uses live market data and live matching engines.</p>
<p ><b>Rithmic Paper Trading :</b> This environment uses live market data, but with a simulator for a matching engine.</p>
<p >Each installation has its own administrative organizations responsible for creating or maintaining that installation's user ids and trading accounts. Typically, whoever issues a user id also handles the administration of that user id and any associated trading accounts. This administrative role includes configuring market data entitlements for user ids and risk management settings for trading accounts. A user id must be entitled to market data from a particular exchange to receive the market data stream. There may also be differences in whether a user can only see the top of the book, or the entire market depth. If a trading account does not have risk management settings configured for a particular instrument or set of instruments, users will not be able to place orders for those instruments on that account. Each user id has the ability to trade on zero to many trading accounts.</p>
<hr  />
<h1><a class="anchor" id="pg_what_is_rapi"></a>
What is R | API+?</h1>
<p >R | API+ (sometimes called R | API or RAPI) is collection of libraries and configuration files constituting a programmatic interface for accessing services provided by Rithmic's R | Trade Execution Platform. By incorporating R | API into your software, you (and your software) may retrieve real-time and historical market data and reference data for various financial securities and contracts, and you may place and manage orders for those securities and contracts. R | API also allows you to obtain account and margin balances, order history and p&amp;l and position information. The specific accounts you may view and access, the instruments you may trade, the market data you may view and the number of concurrent connections you may maintain to R | Trade Execution Platform is subject to restrictions and permissions established by your Futures Commission Merchant (FCM), your Broker-Dealer or your Introducing Broker (IB), as the case may be.</p>
<h2><a class="anchor" id="pg_cpp_vs_dotnet"></a>
C++ vs. .NET</h2>
<p >There are two compilations of R | API, one for C++ and the other for .NET. The interface for the C++ compilation does not make use of 'modern' C++ and should be accessible to anyone with knowledge of C or 'classic' C++. Furthermore, the C++ classes do not necessarily adhere to standard STL conventions and should be used with care in an STL environment.</p>
<p >As much as possible the feature set and interface exposed by both compilations are the same, but because they are built on different underlying libraries, some differences remain, including obvious differences such as the use of properties in .NET as well as more subtle differences such as the threading model used for handling events. In general, the behavior of the two compilations is kept as close as possible.</p>
<p >The .NET compilation of R | API is a pure .NET library. It does not contain unmanaged code.</p>
<h2><a class="anchor" id="pg_which_api_for_me"></a>
R | API+ and R | Diamond Cutter</h2>
<p >There are two variations of R | API, both using the same basic object model. R | API+ provides trading infrastructure services. R | Diamond Cutter includes everything R | API+ has, with additional functionality for ultra low latency applications. R | Diamond Cutter is only offered in C++.</p>
<p >R | API (no plus) has been discontinued.</p>
<hr  />
<h1><a class="anchor" id="pg_os_platforms"></a>
Operating Systems, Frameworks, Compilers and Target Platforms</h1>
<p >The Rithmic APIs make use of a set of libraries licensed from Omnesys Technologies, Inc. These libraries and the Rithmic APIs have been built on several operating systems and frameworks with specific compilers for use on specific target platforms as indicated below. Please be sure to build your software using only the compilers and frameworks listed below on machines running the associated operating systems. Support will not be provided for software built any other way and support will not be provided for software run on any other operating systems and/or frameworks. Also, support will not be provided for software run on any operating system and/or framework emulators.</p>
<h2><a class="anchor" id="pg_cpp_compilation"></a>
The C++ compilation of Rithmic APIs have been built as follows:</h2>
<center> <table class="doxtable">
<tr>
<th>Build Operating System </th><th>Compiler </th><th>Target Platform  </th></tr>
<tr>
<td>Darwin 10.8.0 for darwin-10 (64-bit darwin) </td><td>gcc/g++ 4.1.2 </td><td>Darwin 10.8.0 for darwin-10 (64-bit darwin)  </td></tr>
<tr>
<td>Darwin 20.6 for darwin-20.6-arm64 (M1) </td><td>gcc/g++ (clang-1300.0.29.30) </td><td>Darwin 20.6 for darwin-20.6-arm64 (M1)  </td></tr>
<tr>
<td>RHEL 6.3 for linux-gnu-2.6.32-x86_64 (64-bit linux) </td><td>gcc/g++ 4.4.6 </td><td>RHEL 6.3 for linux-gnu-2.6.32-x86_64 (64-bit linux)  </td></tr>
<tr>
<td>RHEL 7.0 for linux-gnu-3.10.0-x86_64 (64-bit linux) </td><td>gcc/g++ 4.8.2 </td><td>RHEL 7.0 for linux-gnu-3.10.0-x86_64 (64-bit linux)  </td></tr>
<tr>
<td>RHEL 8.5 for linux-gnu-4.18-x86_64 (64-bit linux) </td><td>gcc/g++ 8.5.0 </td><td>RHEL 8.5 for linux-gnu-4.18-x86_64 (64-bit linux)  </td></tr>
<tr>
<td>Windows 10 Professional (64-bit) </td><td>Visual Studio 2015 Professional </td><td>Windows 10 Professional (32-bit)  </td></tr>
</table>
</center><h2><a class="anchor" id="pg_dotnet_compilation"></a>
The .NET compilation of Rithmic APIs have been built with a target framework of .NET 3.5 as follows:</h2>
<center> <table class="doxtable">
<tr>
<th>Build Operating System </th><th>Compiler </th><th>Target Platform  </th></tr>
<tr>
<td>Windows (64-bit) </td><td>Visual Studio 2010 Professional </td><td>AnyCPU on .NET Framework 3.5  </td></tr>
</table>
</center><hr  />
<h1><a class="anchor" id="pg_file_list"></a>
Installation and File List</h1>
<p >Rithmic APIs are distributed as a compressed set of files (a zip archive) which can be extracted using standard utilities. The top level directory within the zip archive is the version number of the API. Beneath this directory are documentation and assorted files necessary for building programs that incorporate the API.</p>
<h2><a class="anchor" id="pg_cpp_files"></a>
Files in the C++ Compilation</h2>
<center> <table class="doxtable">
<tr>
<th>File or Sub-directory </th><th>Description  </th></tr>
<tr>
<td>darwin-10/lib/ </td><td>Directory containing libraries to link against when building for darwin-10  </td></tr>
<tr>
<td>darwin-20.6/lib/ </td><td>Directory containing libraries to link against when building for Apple's M1 architecture  </td></tr>
<tr>
<td>documentation.html </td><td>Start page for html documentation (Redirects to doc/html/index.html)  </td></tr>
<tr>
<td>etc/ </td><td>Directory containing SSL/TLS files  </td></tr>
<tr>
<td>include/ </td><td>Directory containing the include file  </td></tr>
<tr>
<td>linux-gnu-2.6.32-x86_64/lib/ </td><td>Directory containing libraries to link against when building for linux-gnu-2.6.32-x86_64  </td></tr>
<tr>
<td>linux-gnu-3.10.0-x86_64/lib/ </td><td>Directory containing libraries to link against when building for linux-gnu-3.10.0-x86_64  </td></tr>
<tr>
<td>linux-gnu-4.18-x86_64/lib/ </td><td>Directory containing libraries to link against when building for linux-gnu-4.18-x86_64  </td></tr>
<tr>
<td>samples/ </td><td>Directory containing sample code  </td></tr>
<tr>
<td>win10/lib/ </td><td>Directory containing libraries to link against when building for Windows 10  </td></tr>
<tr>
<td>Release.Notes </td><td>Change log  </td></tr>
</table>
</center><h2><a class="anchor" id="pg_dotnet_files"></a>
Files in the .NET Compilation</h2>
<center> <table class="doxtable">
<tr>
<th>File or Sub-directory </th><th>Description  </th></tr>
<tr>
<td>documentation.html </td><td>Start page for html documentation (Redirects to doc/html/index.html)  </td></tr>
<tr>
<td>samples/ </td><td>Directory containing sample code.  </td></tr>
<tr>
<td>win10/lib/ </td><td>Directory containing libraries to link against when building for Windows (.NET Framework 3.5).  </td></tr>
<tr>
<td>Release.Notes </td><td>Change log  </td></tr>
</table>
</center><hr  />
<h1><a class="anchor" id="pg_building_cpp"></a>
Building A C++ Rithmic API Application</h1>
<p >In the samples directory there are VS2010 and VS2015 sample solutions. The VS2015 sample solution should be opened, then converted, if using a later version of Visual Studio. Also, in the comments at the top of each source file, there is a compile/link line one can use in unix-like operating systems. There is also information about configuring, building and running the sample code in the <a class="el" href="quick_start.html">Quick Start</a>.</p>
<p >To compile an application which uses a Rithmic API library, your compiler must know the location of the header file. The header file name will be "RApiPlus.h" or "RDiamondApi.h", depending on which product you are using.</p>
<h2><a class="anchor" id="pg_building_cpp_windows"></a>
Building C++ On Windows Using Visual Studio</h2>
<h3><a class="anchor" id="pg_compiling_windows"></a>
Compiling On Windows</h3>
<p >Code should be generated with the run-time libraries set to Multi-threaded (/MT), Multi-threaded Debug (/MTd), Multi-threaded DLL (/MD), or Multi-threaded Debug DLL (/MDd). Code should be compiled with run-time type information enabled (/GR).</p>
<p >If you are compiling the sample code, you should define "WinOS".</p>
<h3><a class="anchor" id="pg_linking_windows"></a>
Linking On Windows</h3>
<p >To link an application under Windows, you will need to link with a number of libraries included in the <a class="el" href="namespaceRApi.html">RApi</a> package under the win7\lib directory for Visual Studio 2010 libraries, and the win10\lib directory for Visual Studio 2015 libraries. The libraries built with Visual Studio 2015 should work with later versions of Visual Studio. All the libraries are named with different suffixes indicating the code generation flag used when compiling : </p><ul>
<li>
*_mdd.lib indicates /MDd on 32-bit platforms </li>
<li>
*_md.lib indicates /MD on 32-bit platforms </li>
<li>
*_mtd.lib indicates /MTd on 32-bit platforms </li>
<li>
*_mt.lib indicates /MT on 32-bit platforms </li>
<li>
*_mdd64.lib indicates /MDd on 64-bit platforms </li>
<li>
*_md64.lib indicates /MD on 64-bit platforms </li>
<li>
*_mtd64.lib indicates /MTd on 64-bit platforms </li>
<li>
*_mt64.lib indicates /MT on 64-bit platforms </li>
</ul>
<p >So, if the code was compiled using Multi-threaded DLL (/MD) for the 32-bit platform, the following libraries would be used to link :</p>
<ul>
<li>
kit_md.lib </li>
<li>
apistb_md.lib </li>
<li>
api_md.lib </li>
<li>
OmneEngine_md.lib </li>
<li>
OmneChannel_md.lib </li>
<li>
OmneStreamEngine_md.lib </li>
<li>
RApiPlus_md.lib (or RDiamondApi_md.lib) </li>
</ul>
<p >You will also need these SSL/TLS libraries from OpenSSL (also included in the <a class="el" href="namespaceRApi.html">RApi</a> package) :</p>
<ul>
<li>
libcrypto_md.lib </li>
<li>
libssl_md.lib </li>
</ul>
<p >And these zlib libraries (also included in the <a class="el" href="namespaceRApi.html">RApi</a> package) :</p>
<ul>
<li>
zlib_md.lib </li>
</ul>
<p >You may also need to specify these system libraries :</p>
<ul>
<li>
ws2_32.lib </li>
<li>
iphlpapi.lib </li>
<li>
psapi.lib </li>
<li>
crypt32.lib </li>
</ul>
<p >If you are using the /NODEFAULTLIB switch, you will need the following libraries:</p>
<ul>
<li>
kernel32.lib </li>
<li>
gdi32.lib </li>
<li>
advapi32.lib </li>
<li>
user32.lib </li>
<li>
bcrypt.lib </li>
</ul>
<p >You also need to link with The C (and possibly C++) runtime libraries. The C runtime library names have changed between Visual Studio 2010 and Visual Studio 2015.</p>
<p >For Visual Studio 2010 C runtime libraries, use :</p>
<ul>
<li>
msvcrt.lib (/MD) or libcmt.lib (/MT) or msvcrtd.lib (/MDd) or libcmtd.lib (/MTd) </li>
<li>
OLDNAMES.lib </li>
</ul>
<p >For Visual Studio 2015 C runtime libraries use :</p>
<ul>
<li>
ucrt.lib (/MD) or libucrt.lib (/MT) or ucrtd.lib (/MDd) or libucrtd.lib (/MTd) </li>
<li>
vcruntime.lib (/MD) or libvcruntime.lib (/MT) or vcruntimed.lib (/MDd) or libvcruntimed.lib (/MTd) </li>
<li>
msvcrt.lib (/MD) or libcmt.lib (/MT) or msvcrtd.lib (/MDd) or libcmtd.lib (/MTd) </li>
<li>
legacy_stdio_definitions.lib </li>
<li>
OLDNAMES.lib </li>
</ul>
<p >If you are using the standard C++ runtime library, you may need the following libraries:</p>
<ul>
<li>
msvcprt.lib (/MD) or  </li>
<li>
libcpmt.lib (/MT) </li>
<li>
msvcprtd.lib (/MDd) or  </li>
<li>
libcpmtd.lib (/MTd) </li>
</ul>
<hr  />
<h2><a class="anchor" id="pg_building_cpp_linux"></a>
Building C++ On Linux Using GCC/g++</h2>
<p >Each of the sample code source files includes in the comments at the top of the file, a build line for that sample. You shouldn't need to modify it if your working directory is the ./samples directory and you are using the RApiPlus.cpp package.</p>
<p >If you are using the RDiamondApi.cpp package, you will have to edit the name of the <a class="el" href="namespaceRApi.html">RApi</a> library you link against.</p>
<h3><a class="anchor" id="pg_compiling_linux"></a>
Compiling On Linux</h3>
<p >Internal testing is done using the following compiler flags : </p><ul>
<li>
-DLINUX </li>
<li>
-D_REENTRANT </li>
<li>
-Wall </li>
<li>
-Wno-sign-compare </li>
<li>
-Wno-write-strings </li>
<li>
-Wpointer-arith </li>
<li>
-Winline </li>
<li>
-Wno-deprecated </li>
<li>
-fno-strict-aliasing </li>
</ul>
<h3><a class="anchor" id="pg_linking_linux"></a>
Linking On Linux</h3>
<p >To link an application under linux, you will need to link with the following libraries (included in the <a class="el" href="namespaceRApi.html">RApi</a> package) :</p>
<ul>
<li>
RApiPlus-optimize (or RDiamondApi-optimize) </li>
<li>
OmneStreamEngine-optimize </li>
<li>
OmneChannel-optimize </li>
<li>
OmneEngine-optimize </li>
<li>
_api-optimize </li>
<li>
_apipoll_stubs-optimize <br  />
 </li>
<li>
_kit-optimize <br  />
 </li>
</ul>
<p >For RHEL 6, you may also need to link with the following system, SSL and z libraries. <br  />
 Some are included in the zip file in case one wishes to use them. :</p>
<ul>
<li>
ssl (included)  </li>
<li>
crypto (included)  </li>
<li>
krb5 </li>
<li>
k5crypto </li>
<li>
com_err </li>
<li>
resolv </li>
<li>
m </li>
<li>
pthread </li>
<li>
rt </li>
<li>
z </li>
</ul>
<p >This compile/link line for SampleMD.cpp using R | API+ works on 64-bit linux of the 2.6.32 kernal (RHEL 6.x). You shouldn't need to modify anything if your working directory is the ./samples directory. </p><pre class="fragment">g++ -O3 -DLINUX -D_REENTRANT -Wall -Wno-sign-compare -Wno-write-strings -Wpointer-arith -Winline -Wno-deprecated -fno-strict-aliasing -I../include -o SampleMD ../samples/SampleMD.cpp -L../linux-gnu-2.6.32-x86_64/lib -lRApiPlus-optimize -lOmneStreamEngine-optimize -lOmneChannel-optimize -lOmneEngine-optimize -l_api-optimize -l_apipoll-stubs-optimize -l_kit-optimize -lssl -lcrypto -L/usr/lib64 -lz -L/usr/kerberos/lib -lkrb5 -lk5crypto -lcom_err -lresolv -lm -lpthread -lrt
</pre><p >For RHEL 7, the list is similar, but shorter. If the linker claims it "cannot find -ld", you may need to install the package "libzip-devel".</p>
<ul>
<li>
ssl (included)  </li>
<li>
crypto (included)  </li>
<li>
pthread </li>
<li>
rt </li>
<li>
z </li>
</ul>
<p >This compile/link line for SampleMD.cpp using R | API+ works on 64-bit linux of the 3.10.0 kernal (RHEL 7.x). You shouldn't need to modify anything if your working directory is the ./samples directory. </p><pre class="fragment">g++ -O3 -DLINUX -D_REENTRANT -Wall -Wno-sign-compare -Wno-write-strings -Wpointer-arith -Winline -Wno-deprecated -fno-strict-aliasing -I../include -o SampleMD ../samples/SampleMD.cpp -L../linux-gnu-3.10.0-x86_64/lib -lRApiPlus-optimize -lOmneStreamEngine-optimize -lOmneChannel-optimize -lOmneEngine-optimize -l_api-optimize -l_apipoll-stubs-optimize -l_kit-optimize -lssl -lcrypto -L/usr/lib64 -lz -lpthread -lrt -ldl
</pre><hr  />
<h2><a class="anchor" id="pg_building_cpp_darwin"></a>
Building C++ On Darwin Using GCC/g++</h2>
<h3><a class="anchor" id="pg_compiling_darwin"></a>
Compiling On Darwin</h3>
<p >Internal testing is done using the following compiler flags : </p><ul>
<li>
-D_REENTRANT </li>
<li>
-Wall </li>
<li>
-Wno-sign-compare </li>
<li>
-fno-strict-aliasing </li>
<li>
-Wpointer-arith </li>
<li>
-Winline </li>
<li>
-Wno-deprecated </li>
<li>
-Wno-write-strings </li>
</ul>
<h3><a class="anchor" id="pg_linking_darwin"></a>
Linking On Darwin</h3>
<p >To link an application under Darwin, you will need to link with the following libraries (included in the <a class="el" href="namespaceRApi.html">RApi</a> package) :</p>
<ul>
<li>
RApiPlus-optimize (or RDiamondApi-optimize) </li>
<li>
OmneStreamEngine-optimize </li>
<li>
OmneChannel-optimize </li>
<li>
OmneEngine-optimize </li>
<li>
_api-optimize </li>
<li>
_apipoll_stubs-optimize <br  />
 </li>
<li>
_kit-optimize <br  />
 </li>
</ul>
<p >You may also need to link with the following system, SSL and z libraries. <br  />
 Some are included in the <a class="el" href="namespaceRApi.html">RApi</a> package in case one wishes to use them. :</p>
<ul>
<li>
ssl (included)  </li>
<li>
crypto (included)  </li>
<li>
krb5 </li>
<li>
resolv </li>
<li>
m </li>
<li>
pthread </li>
<li>
z </li>
</ul>
<p ><a class="anchor" id="pg_darwin_make"></a>This compile/link line for SampleMD.cpp works on (64-bit) darwin-10. You shouldn't need to modify anything if your working directory is the ./samples directory. </p><pre class="fragment">g++ -O3 -D_REENTRANT -Wall -Wno-sign-compare -fno-strict-aliasing -Wpointer-arith -Winline -Wno-deprecated -Wno-write-strings -I../include -o ./SampleMD ../samples/SampleMD.cpp -L../darwin-10/lib -lRApiPlus-optimize -lOmneStreamEngine-optimize -lOmneChannel-optimize -lOmneEngine-optimize -l_api-optimize -l_apipoll-stubs-optimize -l_kit-optimize -lssl -lcrypto -L/usr/lib -lz -Wl,-search_paths_first
</pre><p >This compile/link line for SampleMD.cpp works on darwin-20.6-arm64. You shouldn't need to modify anything if your working directory is the ./samples directory. </p><pre class="fragment">g++ -O3 -D_REENTRANT -Wall -Wno-sign-compare -fno-strict-aliasing -Wpointer-arith -Winline -Wno-deprecated -Wno-write-strings -I../include -o ./SampleMD ../samples/SampleMD.cpp -L../darwin-20.6-arm64/lib -lRApiPlus-optimize -lOmneStreamEngine-optimize -lOmneChannel-optimize -lOmneEngine-optimize -l_api-optimize -l_apipoll-stubs-optimize -l_kit-optimize -lssl -lcrypto -L/usr/lib -lz
</pre><hr  />
<h1><a class="anchor" id="pg_building_dotnet"></a>
Building A .NET Rithmic API Application</h1>
<p >Building in .NET using Visual Studio is relatively easy.</p>
<ul>
<li>
Add a reference to rapi.dll to your project or solution. </li>
<li>
Add a <b>using</b> directive 'using com.omnesys.omne.om;' to the appropriate source files. </li>
<li>
Add another <b>using</b> directive 'using com.omnesys.rapi;' to the appropriate source files. </li>
<li>
Build the application. </li>
</ul>
<hr  />
<h1><a class="anchor" id="pg_classes"></a>
Organization Of Rithmic API Classes</h1>
<h2><a class="anchor" id="pg_class_categories"></a>
There are three main categories of classes in the Rithmic APIs :</h2>
<ul>
<li>The first category contains the 'action' class. For R | API it is REngine. All actions are initiated by calls to methods of that class. The methods of REngine represent the available services from the infrastructure.</li>
</ul>
<ul>
<li>The second category is for callback classes. Rithmic APIs typically request network services asynchronously. These requests are processed by the infrastructure and the responses are conveyed via methods of callback classes. There are a small number of callback classes : <ul>
<li>
AdmCallbacks for administrative callbacks, and </li>
<li>
RCallbacks for REngine callbacks (primary callback class for R | API). </li>
</ul>
</li>
</ul>
<ul>
<li>The third category is for 'Info' classes, which convey information specific to a particular callback method. These class names typically end in 'Info', such as RefDataInfo.</li>
</ul>
<p>The names of an REngine method, its corresponding callback method, and the class used to convey the callback specific information are usually, but not always, similar.</p>
<p >For example :</p>
<ul>
<li>REngine::replayPnl() - Requests a snapshot of pnl information for a given account. </li>
<li>RCallbacks::PnlReplay() - The callback method invoked when the response to the request has been received and processed. </li>
<li>PnlReplayInfo - The actual pnl information being returned.</li>
</ul>
<p>Subscriptions are a notable exception to the naming conventions. Calls to REngine::subscribe() and REngine::subscribeOrder() can result in a number of different callbacks being invoked.</p>
<h2><a class="anchor" id="pg_class_dump_method"></a>
The dump() Method</h2>
<p >The dump() method that all the Info classes support is a utility method that prints the object contents to stdout. It is deprecated and may be removed in a future release.</p>
<hr  />
<h1><a class="anchor" id="pg_configuring"></a>
Configuring A Rithmic API Application</h1>
<p >A Rithmic API application must connect to at least one Rithmic system. (It is possible to connect to more than one system, but that is a more advanced topic not addressed here.) The system to which an REngine instance connects to depends on the configuration passed to the REngine constructor by REngineParams. Along with the REngine constructor, the REngine::login() routine indicates where (within the Rithmic system) the Rithmic API application will connect, and which what credentials.</p>
<h2><a class="anchor" id="pg_configuring_configuration_files"></a>
Configuration Files</h2>
<p >Settings to various Rithmic systems are distributed by the Rithmic operations team in 'connection_params.txt' files, usually made available in your download directory. These files contain information that is needed by the REngine constructor and the REngine::login() routine to connect to a particular Rithmic system. The prefix of the file name should identify the Rithmic system, and the version number in the file name is an 'as-of' version. It is possible that the version of your R | API is greater than the configuration file's 'as-of' version. The file name might also identify the gateway represented by the configuration. A gateway is a point-of-presence for a Rithmic system. For example, Rithmic 01 has gateways in North America, South America, Europe and Asia. Sometimes users find that one gateway (often geographically closer) is more reliable than another.</p>
<p >The sample code (e.g. SampleMD or SampleOrder) is hard-coded to connect to Rithmic Test via our Orangeburg gateway. The Rithmic Test configuration files are also available in each download directory. The file name as of this writing is "Rithmic_Test_Orangeburg_rapi_connection_params_10.5.0.0.txt". One can review the relationship between this configuration file and the sample code to see how the file contents map into code.</p>
<p >Rithmic systems and their associated configuration information can be added, modified, or removed from time to time. Vendors of trading applications built on R | API can find it useful to support the ability to dynamically incorporate these kinds of configuration changes.</p>
<h2><a class="anchor" id="pg_configuring_conformance"></a>
Conformance and Fees</h2>
<p >An R | API application must go through conformance before the connection_params text file containing settings for systems other than Rithmic Test are made available. Most environments requiring conformance make use of live market data and/or live accounts.</p>
<p >Associated with live data or trading can be fees. Fees can vary greatly depending on how many concurrent market data connections a user is entitled to (see <a class="el" href="programmers_guide.html#pg_max_session_count">Max Session Counts</a>), as well as the number of exchanges for which market data is entitled. For users writing their own apps, it is recommended that when going through conformance, you also consult with your broker or fcm to understand any fees associated with using the R | API with these additional Rithmic systems.</p>
<p >To begin conformance, please contact Rithmic at <a href="#" onclick="location.href='mai'+'lto:'+'rap'+'i@'+'rit'+'hm'+'ic.'+'co'+'m'; return false;">rapi@<span class="obfuscator">.nosp@m.</span>rith<span class="obfuscator">.nosp@m.</span>mic.c<span class="obfuscator">.nosp@m.</span>om</a>.</p>
<hr  />
<h1><a class="anchor" id="pg_max_session_count"></a>
Max Session Counts</h1>
<p >The configuration of each user's maximum number of concurrent connections is called the Max Session Count. A user has a Max Session Count for orders, and another Max Session Count for market data. One can view their max session counts using R | Trader Pro by opening the File menu, and selecting User Profile. <br  />
</p>
<p >When a user exceeds their max session count, the infrastructure will automatically disconnect that user's oldest login session. As a courtesy, the infrastructure will alert the client application prior to severing the connection. This alert appears as a Forced Logout alert in RCallbacks::Alert(). When an RAPI client receives a Forced Logout alert, it will log out entirely from the infrastructure, not just the connection on which the forced logout alert arrived.</p>
<p >The Max Session Counts apply per connection. The market data count applies to the market data connect point and to the history connect point. The orders count applies to the trading system connect point and the pnl connect point. So, for example, if a user has a max session count of 2 for market data, they can connect twice to the market data connect point, and twice to the history connect point. If they connect a third time to the market data connect point, their oldest login session will receive a forced logout alert and then will either log out gracefully (if there is time), or have it's connection severed by the infrastructure.</p>
<hr  />
<h1><a class="anchor" id="pg_plugins"></a>
Using R | Trader Pro as a Plug-In Host</h1>
<p >It is possible to configure an R | API app to be a plug-in client of R | Trader Pro. When an R | API app is a plug-in client, it will connect to R | Trader Pro as its market data and historical data source. This plug-in arrangement allows for a single market data session of R | Trader Pro to be used for multiple R | API plug-in apps.</p>
<p >Use of plug-in functionality conserves the number of concurrent market data connections a user is entitled to, which can reduce applicable market data fees. (See <a class="el" href="programmers_guide.html#pg_max_session_count">Max Session Counts</a>.) Many users have a max session count for market data of one, and a higher max session count for orders. This allows them to use one connection (plug-in host + N plug-in clients) for market data, and multiple direct connections for orders.</p>
<p >Below are the steps to run a plug-in host and client :</p>
<ol type="1">
<li>Download, install, and then run R | Trader Pro as a plug-in host. You can get a version from the Rithmic website. Versions 15.x.y.z and below do not support plug-in functionality.</li>
</ol>
<p >1a. From R | Trader Pro's login screen, enable "Allow Plug-ins". It will turn yellow when enabled. You may need to click on Advanced to get to the "Allow Plug-ins" setting.</p>
<p >1b. Enter your normal credentials for the Orders system and gateway as well as for the Market Data system and gateway. It is possible to mix-and-match which Rithmic system one logs into for orders and for market data.</p>
<p >1c. Using your favorite TCP utility, you can verify that the plug-in host is running by seeing that 127.0.0.1:3010 and 127.0.0.1:3012 are being listened to for TCP.</p>
<ol type="1">
<li>Change the configuration of your RAPI app to use the plug-in.</li>
</ol>
<p >2a. Define two environment variables before instantiating REngine. RAPI_MD_ENCODING=4 and RAPI_IH_ENCODING=4. In .NET you might use System.SetEnvironmentVariable(). In C++ the environment variables have to be in REngineParams::envp. You should be able to see these environment variables in your RAPI log file. You can also use the REngine routines available to manage environment variables, such as REngine::setEnvironmentVariable(), if you have already instantiated the REngine instance.</p>
<p >2b. Use "127.0.0.1:3010" as your MdCnnctPt and "127.0.0.1:3012" as your IhCnnctPt.</p>
<p >2c. When logging into your RAPI app, the credentials used for the MdCnnctPt and IhCnnctPt must match the credentials entered into R | Trader Pro for its Market Data connection.</p>
<hr  />
<h1><a class="anchor" id="pg_environments"></a>
Connecting to Multiple Rithmic Systems Simultaneously Using Environments</h1>
<p >R | API looks for configuration information from environment variables and/or during the REngine constructor. A properly configured set of environment variables associates itself with a particular Rithmic system. However, it is possible for one instance of REngine to be associated with multiple Rithmic systems. This enables users to connect to one system for their market data, and another system for their trading.</p>
<p >Note : The discussion which follows assumes a familiarity with the idea of environment variables (name value pairs) that exist in operating system process spaces.</p>
<h2><a class="anchor" id="pg_environments_background"></a>
Background</h2>
<p >Historically, one set of environment variables was conveyed to the REngine constructor via REngineParams, either as an array of C-style strings (in C++) or as properties of REngineParams (in .NET). The REngine would also examine the process space for additional environment variables. With this approach, each instance of REngine was associated with a single environment, and consequently, a single Rithmic system.</p>
<h2><a class="anchor" id="pg_environments_multiple_environments"></a>
Multiple Environments</h2>
<p >However, there are cases where one instance of REngine may need to connect to multiple Rithmic systems. For example, a user may have a market data subscription in Rithmic System A, with a trading account on Rithmic System B. Having the ability to connect simultaneously to system A for market data and system B for placing orders would remove the need for another (redundant and/or costly) market data subscription in Rithmic System B.</p>
<p >To support these use cases, the REngine class now supports multiple environments. Each environment is keyed with an identifying string. There is a default key of "system" for the default environment, taken during the REngine constructor. When logging in, one can specify which environment to use with a connect point. The design intent is for an environment to correspond to a particular gateway of a Rithmic system.</p>
<p >When specifying keyed environments when logging in, the environment will be validated for the presence of the minimal number of connection-related variables.</p>
<center> <table class="doxtable">
<tr>
<th>Environment Variable </th><th>C++ </th><th>.NET  </th></tr>
<tr>
<td>MML_DMN_SRVR_ADDR </td><td>required </td><td>required, corresponds to REngineParams.DmnSrvrAddr  </td></tr>
<tr>
<td>MML_DOMAIN_NAME </td><td>required </td><td>required, corresponds to REngineParams.DomainName  </td></tr>
<tr>
<td>MML_LIC_SRVR_ADDR </td><td>required </td><td>required, corresponds to REngineParams.LicSrvrAddr  </td></tr>
<tr>
<td>MML_LOC_BROK_ADDR </td><td>required </td><td>required, corresponds to REngineParams.LocBrokAddr  </td></tr>
<tr>
<td>MML_LOGGER_ADDR </td><td>required </td><td>required, corresponds to REngineParams.LoggerAddr  </td></tr>
<tr>
<td>MML_LOG_TYPE </td><td>required </td><td>not used  </td></tr>
<tr>
<td>MML_SSL_CLNT_AUTH_FILE </td><td>required </td><td>not used  </td></tr>
<tr>
<td>USER </td><td>required </td><td>not used  </td></tr>
</table>
</center><h2><a class="anchor" id="pg_environments_single_environment"></a>
Prior Behavior With A Single Environment</h2>
<p >If there is no need to use multiple environments, one can specify an empty string for the environment key when logging in. This approach will mirror behavior prior to the introduction of multiple environment functionality.</p>
<h2><a class="anchor" id="pg_environments_comments"></a>
Comments</h2>
<ul>
<li>
<p class="startli">R | API programmers, especially vendors, may wish to keep any environment-related configurations outside of their application binary, as these configurations can change over time. Configuration files are an example of this approach.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When connecting to a plug-in host, the environment does not matter, as the connect point is on the loopback adapter. However, the user/password credentials must match the credentials entered into the plug-in host.</p>
<p class="endli"></p>
</li>
<li>
Setting an operating system process space's environment variable while an R | API app is running will not cause that environment variable to appear in the REngine's default system environment. When in doubt, verify that the desired set of environment variables and values exist using the REngine routines. </li>
</ul>
<h2><a class="anchor" id="pg_environments_interface"></a>
Programming Interface</h2>
<p >Programmers can use the following routines to list/get/set/unset environment variables. These routines require an REngine instance, so a default environment passed via REngineParams will always exist. Each environment is keyed by a string. The default environment from REngineParams has a key of "system". </p><pre class="fragment"> RApi::REngine::listEnvironments()
 RApi::REngine::getEnvironment()
 RApi::REngine::setEnvironmentVariable()
 RApi::REngine::unsetEnvironmentVariable()
 RApi::sDEFAULT_ENVIRONMENT_KEY (c++) or Constants.DEFAULT_ENVIRONMENT_KEY (.NET)
</pre> <hr  />
<h1><a class="anchor" id="pg_connections"></a>
Connections</h1>
<p >Applications built on Rithmic APIs establish multiple connections to the Rithmic trading platform. Some connections are transient, while others are persistent. The transient connections can appear as environment variables or values in REngineParams. Persistent connections are specified as connect points.</p>
<h2><a class="anchor" id="pg_cnnct_pts"></a>
Connect Points</h2>
<p ><a class="el" href="programmers_guide.html#pg_what_is_rtrade">Above</a>, we learned that there are multiple installations of the R | Trade Execution Platform, i.e. the different Rithmic systems. We also <a class="el" href="programmers_guide.html#pg_environments">learned</a> that each environment is associated with a particular Rithmic system.</p>
<p >A connect point is a logical name for a network address within a Rithmic system. Each connect point exposes a different set of services. More explicitly, the connect point + environment yields an IP and port. The environment drives how the connect point is resolved, so the same connect point string value might resolve differently if paired with a different environment.</p>
<p >Connect points are also where user credentials are submitted. Because a connect point is associated with a particular Rithmic system, the user id and password passed into that connect point must also match the associated Rithmic system. In other words, logging in to a specific system requires an environment, a connect point, a user and a password.</p>
<p >An exception to how credentials are handled is when connecting to a plug-in host. When connecting to a plug-in host, the user id and password must match what was entered for the plug-in host, regardless of the environment specified. Plug-in host connect points differ in that they are in the IP:port form and do not need to be resolved.</p>
<p >Another exception is the administrative connect point specified in REngineParams. The administrative connect point does not use credentials.</p>
<p >The following connect points are used in R | API : </p><ul>
<li>
<a class="el" href="classRApi_1_1LoginParams.html#a62a21989bb9cd742351be803b2dbedf3">RApi::LoginParams::sMdCnnctPt</a> - Connect point for the ticker plant. This connect point is required for real-time market data services. </li>
<li>
<a class="el" href="classRApi_1_1LoginParams.html#a39807f7c99c5b09b201df6f55e65b727">RApi::LoginParams::sTsCnnctPt</a> - Connect point for the order plant, providing order handling services. </li>
<li>
<a class="el" href="classRApi_1_1LoginParams.html#a76e4ccdec0681d7813158ae74a57f4e6">RApi::LoginParams::sPnlCnnctPt</a> - Connect point for the pnl, providing pnl snapshots and updates. The environment used for this connect point is always the same as the environment used for the order plant. </li>
<li>
<a class="el" href="classRApi_1_1LoginParams.html#ab3d51732601f10b56ddea5a470513fac">RApi::LoginParams::sIhCnnctPt</a> - Connect point to history plant for historical (not real-time) market data such as candlestick/bar data. </li>
</ul>
<p >If one does not specify a particular connect point, a connection to that sub-system will not be esablished, and access to the services provided by that segment of R | Trade Execution Platform will be unavailable to the REngine. The most common error returned in this case will be a 'no handle' error.</p>
<p >Connect points available for a particular Rithmic system are distributed by the Rithmic operations team in a 'connection_params.txt' file. These text files are generally distributed via the user's download directory on the Rithmic webserver. See the above discussion on <a class="el" href="programmers_guide.html#pg_configuring">Configuring A Rithmic API Application</a> for more information.</p>
<h2><a class="anchor" id="pg_connection_aggregated_data"></a>
Aggregated Data Market Data</h2>
<p >Rithmic installations may also offer aggregated market data feeds. End users with limited end-to-end network bandwidth or other computing limitations may prefer using these aggregated market data feeds for an improved user experience.</p>
<p >With aggregated market data, updates to certain types of data are accummulated and periodically the most recent version of that data is published. The publishing frequency may depend on the Rithmic system's configuation, but is generally set to 0.25 seconds. So, for example, if the best bid/ask prices or quantities change many times over the 0.25 second interval, only the most recent values are published. There are also types of data which are not aggregated, such as trades. Trades pass through without any aggregation.</p>
<p >To make use of an aggregated market data feed, one would use the market data connect point for the aggregated feed instead of for the normal/raw market data feed. In other words, when logging in, one changes the market data connect point value to switch between aggregated and non-aggregated market data feeds.</p>
<p >Aggregated market data connect point values are also found in the connection_params files.</p>
<h2><a class="anchor" id="pg_connection_locations"></a>
Gateways and Points-Of-Presence</h2>
<p >Some Rithmic installations have multiple "Gateways". A gateway is a geographically local point-of-presence providing access to a particular Rithmic system. There may be multiple gateways to a single Rithmic system. These gateways may be spread throughout the world, such as in North America, South America, Europe and Asia. Some end users find that using a different (perhaps geographically closer?) gateway improves their user experience.</p>
<p >For example, in Europe, an end user might find that the Frankfurt gateway offers the best performance/user experience. The very best performance can be obtained by colocating your program with Rithmic. Colocation services are available from our sister company, <a href="https://theomne.net" target="_blank">TheOmne.net</a>. When you colocate, you use a LAN-only gateway, such as Rithmic 01 Colo 75 or Rithmic Paper Trading Colo 75.</p>
<h2><a class="anchor" id="pg_connection_best_practices"></a>
Best Practices</h2>
<p >Because there are many Rithmic systems, each with multiple gateways, application developers often find that keeping connection point settings (i.e. the parameters to the REngine constructor and to REngine::login()) configurable, and outside of their application binary.</p>
<p >In this way, one can add support for new Rithmic systems and/or gateways with a configuration change, rather than rebuilding a binary.</p>
<h2><a class="anchor" id="pg_connection_mgmt"></a>
Connection Management</h2>
<p >Updates to the status of these connections are provided via RCallbacks::Alert() in R | API. The alert types associated with connections are : </p><ul>
<li>Connection Opened - a connection has been established. </li>
<li>Connection Broken - a connection has been broken or is in recovery. When a connection is broken, R | API will attempt to automatically recover the connection. Subscriptions will be resubmitted automatically as part of the recovery processing. </li>
<li>Connection Closed - a connection has been closed. </li>
<li>Quiet Heartbeat - a heartbeat was not detected. Heartbeats are used to verify the integrity of each connection. It is possible for the quiet heartbeat alert to fire on a good connection if the machine could not run the heartbeat detection routine in time (i.e. cpu too busy, stopped in debugger, etc.). </li>
<li>Login Complete - login credentials were received and accepted. </li>
<li>Login Failed - login credentials were received but not accepted. </li>
<li>Forced Logout - the session is about to be terminated because the maximum number of concurrent sessions of this user have been exceeded. If one connection receives a forced logout alert, the RAPI will log out from all connections in that login session. Users can ask their administrator to increase the maximum number of concurrent sessions.</li>
</ul>
<p>Quiet Heartbeat vs. Connection Broken Alerts</p>
<p >Sometimes a connection will go bad, but the operating system will continue waiting for some timeout period (perhaps optimistically, and perhaps in consideration of very low bandwidth or high latency network connections). In these cases where the connection is truly bad, but with the OS still waiting for the timeout, you may get one or more quiet heartbeat alerts. If (when?) the OS does end up concluding the connection is bad, it will inform the process, which will appear to you via the R | API as a connection broken event. Upon receiving a connection broken event, the R | API will automatically attempt to recover the connection. It will not attempt recovery upon receipt of a quiet heartbeat event. (FYI : It will also not attempt recovery when a login fails authentication either.)</p>
<p >Connecting During A System Reboot</p>
<p >The infrastructure has a schedule to reboot at regular maintenance intervals. Usually this will happen each weekend. When the infrastructure is brought down, R | API client connections to the infrastructure will be broken, triggering connection broken alerts. Although it is possible that the broken connections will recovery automatically and gracefully, it is also possible that a recovery attempt will result in a login failure, despite valid credentials being presented. This failure will happen when the connection points accept connections before the user id/authentication service is on-line. When authentication cannot be verified, login will fail by default. So, it may be necessary to re-initiate logging in after system reboots.</p>
<hr  />
<h1><a class="anchor" id="pg_updates_and_snapshots"></a>
Establishing And Maintaining State With The Snapshot-Update Pattern</h1>
<h2><a class="anchor" id="pg_updates_and_snapshots_establishing_state"></a>
Establishing And Maintaining State</h2>
<p >When first connecting, programs generally need to know the current state of affairs in some area of interest, such as the current order book, or recent orders placed on a particular account. Sometimes this process of figuring out the current state of affairs is called 'establishing state'. Once a program establishes state, it may want to be notified of any updates, or changes to the state of affairs. Keeping track of updates is sometimes referred to as 'maintaining state'. The RAPI provides methods designed to establish and maintain state, by providing methods which retrieve snapshots of data as well as methods which subscribe for updates to that data.</p>
<h2><a class="anchor" id="pg_updates_and_snapshots_polling_snapshots"></a>
Polling Snapshots</h2>
<p >Although it is tempting to continually poll the system by requesting snapshots over and over to keep track of the current state of affairs, doing so is much slower and resource inefficient than using the snapshot-update pattern. The polling approach causes chunks of the database to be transmitted to the RAPI client over and over, even if the data has not changed. There are also limits to how often an application can poll the infrastructure, and exceeding the limits can result in the suspension of services.</p>
<h2><a class="anchor" id="pg_updates_and_snapshots_poll_once"></a>
Poll Once, Then Updates</h2>
<p >The recommended approach to establishing and maintaining state is to apply the snapshot-update pattern. The basic idea of this pattern is to retrieve a snapshot of the state of affairs, and subsequently apply updates to that snapshot. By applying these updates to the snapshot, the application always has the current information. Becaise only information which has changed is transmitted, the increased efficiency can result in dramatic changes in application responsiveness over the polling approach.</p>
<p >Snapshots are provided by databases within the infrastructure, and updates are published as part of the real-time data stream. Most of the RAPI methods which retrieve snapshots begin with 'replay', and most of the methods which subcribe for updates begin with 'subscribe'.</p>
<p >This pattern of snapshots and updates is designed to be efficient and flexible, at the cost of minor complexity. <br  />
</p>
<h2><a class="anchor" id="pg_updates_and_snapshots_example"></a>
An Example With Orders</h2>
<p >An example of the snapshot-updates pattern is when after successfully logging in to the trading system connect point, an application wants to display all orders under an account from today's trading session. In addition, while connected, the application wants to receive any updates to these orders as they occur. The application should first call REngine::subscribeOrder(). This call causes any order updates for the account to be sent to the app. Next, the application should call REngine::replayAllOrders(). This second call requests snapshots of all orders that were active this trading session. As updates are received, they can be applied to the snapshot, with the result providing the current state of affairs. If an update is received before the snapshot arrives, it should be cached, and then applied to the snapshot when it does arrive.</p>
<h2><a class="anchor" id="pg_updates_and_snapshots_subtleties"></a>
Some Subtleties To Be Aware Of</h2>
<p >There are subtleties to this pattern of snapshots and updates. It is important to call the request for updates first, as it is possible an update is published after the snapshot has been requested, but before updates have been requested. If this happens, the update published in between the two calls will be missed if the snapshot was requested first.</p>
<p >Another subtlety is that it is that the snapshot may incorporate an update. In this case, the update was processed by the database before the snapshot request was processed but after the subscription request was processed. By applying any updates that arrived prior to the snapshot in the same sequence that the updates arrived, the resultant state of affairs should be correct and current.</p>
<p >Finally, when subcribing to market depth by price (REngine::subscribe() with the market depth flag enabled), the intricacies of the snapshot-update pattern are internal to the RAPI, so there is no need to explicitly request an order book snapshot.</p>
<dl class="section see"><dt>See also</dt><dd>REngine::replayAllOrders() and REngine::subscribeOrder() </dd>
<dd>
REngine::replayBrackets() and REngine::subscribeBracket() </dd>
<dd>
REngine::replayExecutions() and REngine::subscribeOrder() </dd>
<dd>
REngine::replayOpenOrders() and REngine::subscribeOrder() </dd>
<dd>
REngine::replayPnl() and REngine::subscribePnl()</dd></dl>
<hr  />
<h1><a class="anchor" id="pg_strings_cpp"></a>
Strings And tsNCharcb (C++ Only)</h1>
<p >This section provides an overview of how the tsNCharcb data type is used.</p>
<h2><a class="anchor" id="pg_strings_why_tsncharcb"></a>
Why use the tsNCharcb for representing strings?</h2>
<p >The tsNCharcb is the standard string data structure native to the larger body of work used by Rithmic. It is a lightweight structure compatible with both C and C++ and is used by the libraries the R | API is written on.</p>
<p >Because it includes both a pointer and a length, many common operations can be done more efficiently than with char * strings. For example, when comparing strings, one can test the length of each string first, potentially saving a memory comparison call.</p>
<p >The C++ string type shares some of the characteristics and efficiencies of the tsNCharcb, but the tsNCharcb data structure and its associated body of work pre-date the C++ strings. As a result, the R | API also uses the tsNCharcb instead of the C++ string.</p>
<p >A tsNCharcb represents the absence of a value when the pData is equal to NULL and iDataLen is equal to 0 (zero). Sometimes we will refer to such a tsNCharcb as 'empty'.</p>
<p >When a routine has a pointer to a tsNCharcb as a parameter, and you do not wish to specify that parameter, you can set the pointer value to null, or the tsNCharcb members to null and zero.</p>
<p >When a routine asks for an array of tsNCharcbs, you should provide the array, with each array element being null or containing an empty tsNCharcb.</p>
<h2><a class="anchor" id="pg_strings_cpp_to_tsnchar"></a>
How does one convert a C++ string into a tsNCharcb?</h2>
<div class="fragment"><div class="line"><span class="keywordtype">string</span>    strCpp;</div>
<div class="line"><a class="code hl_struct" href="structsNCharcb.html">tsNCharcb</a> sNChar;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">if (strCpp.empty())</div>
<div class="line">     {</div>
<div class="line">     sNChar.<a class="code hl_variable" href="structsNCharcb.html#a6d19cb7e3e835f8ab4ca70807a72d2b9">pData</a>    = NULL;</div>
<div class="line">     sNChar.<a class="code hl_variable" href="structsNCharcb.html#a2aee0067f4410e24a2d9176760a17b03">iDataLen</a> = 0;</div>
<div class="line">     }</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">     {</div>
<div class="line">     sNChar.<a class="code hl_variable" href="structsNCharcb.html#a6d19cb7e3e835f8ab4ca70807a72d2b9">pData</a>    = (<span class="keywordtype">char</span> *)strCpp.data();</div>
<div class="line">     sNChar.<a class="code hl_variable" href="structsNCharcb.html#a2aee0067f4410e24a2d9176760a17b03">iDataLen</a> = strCpp.length();</div>
<div class="line">     }</div>
<div class="ttc" id="astructsNCharcb_html"><div class="ttname"><a href="structsNCharcb.html">sNCharcb</a></div><div class="ttdoc">String structure used by the RApi. Typically appears in code as the typedef tsNCharcb.</div><div class="ttdef"><b>Definition:</b> RApiPlus.h:18</div></div>
<div class="ttc" id="astructsNCharcb_html_a2aee0067f4410e24a2d9176760a17b03"><div class="ttname"><a href="structsNCharcb.html#a2aee0067f4410e24a2d9176760a17b03">sNCharcb::iDataLen</a></div><div class="ttdeci">int iDataLen</div><div class="ttdef"><b>Definition:</b> RApiPlus.h:20</div></div>
<div class="ttc" id="astructsNCharcb_html_a6d19cb7e3e835f8ab4ca70807a72d2b9"><div class="ttname"><a href="structsNCharcb.html#a6d19cb7e3e835f8ab4ca70807a72d2b9">sNCharcb::pData</a></div><div class="ttdeci">char * pData</div><div class="ttdef"><b>Definition:</b> RApiPlus.h:19</div></div>
</div><!-- fragment --><h2><a class="anchor" id="pg_strings_tsnchar_to_cpp"></a>
How does one convert a tsNCharcb into a C++ string?</h2>
<div class="fragment"><div class="line"><span class="keywordtype">string</span>    strCpp;</div>
<div class="line"><a class="code hl_struct" href="structsNCharcb.html">tsNCharcb</a> sNChar;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">strCpp = string(sNChar.<a class="code hl_variable" href="structsNCharcb.html#a6d19cb7e3e835f8ab4ca70807a72d2b9">pData</a>, sNChar.<a class="code hl_variable" href="structsNCharcb.html#a2aee0067f4410e24a2d9176760a17b03">iDataLen</a>);</div>
</div><!-- fragment --><h2><a class="anchor" id="pg_strings_tsnchar_init"></a>
Do I need to initialize both the pData and the iDataLen of each tsNCharcb?</h2>
<p >Yes. The two should always be consistent. If the string is empty/undefined, the pData should be set to NULL, and the iDataLen should be set to 0 (zero).</p>
<p >If the two values are inconsistent, the behavior of the api is undefined. In the best case, you will get a response of API_BAD_INPUT for some call. In the worst case, your application's memory space will be 'corrupt'.</p>
<p >It is possible to have pData pointing to a legitimate buffer, with iDataLen set to zero.</p>
<h2><a class="anchor" id="pg_strings_memory"></a>
Who owns the memory pointed to by tsNCharcb::pData?</h2>
<p >Whoever allocated the memory is responsible for it. When passing tsNCharcb parameters to the R | API methods, the data will be copied within the method before returning. When the R | API invokes user-defined callbacks, the <a class="el" href="structsNCharcb.html#a6d19cb7e3e835f8ab4ca70807a72d2b9">tsNCharcb::pData</a> memory will most likely become invalid immediately upon exiting the callback method, so if the values will be kept, they need to be copied.</p>
<hr  />
<h1><a class="anchor" id="pg_timestamps"></a>
On Timestamps (ssboe, usecs and nsecs)</h1>
<p >The Rithmic APIs make use of unix time conventions for timestamps. Unix time is the number of Seconds Since the Beginning Of the Epoch (ssboe). The epoch is defined to have begun on Jan 1, 1970 UTC (Universal Coordinated Time). One can find more detailed discussions on unix time on the Internet, as well as documentation on how one might convert unix time to/from other time formats using a variety of technologies.</p>
<p >There is often a microseconds (usecs) portion of the timestamp to accompany the ssboe value. Sometimes there is even a nanoseconds (nsecs) portion.</p>
<p >Both the ssboe, usecs and nsecs values are usually stored as integer types.</p>
<hr  />
<h1><a class="anchor" id="pg_threads"></a>
On Threads</h1>
<h2><a class="anchor" id="pg_threads_cpp"></a>
Threads In C++ API</h2>
<p >The C++ version of the Rithmic APIs will create an internal "worker" thread. Almost all of the callbacks will be invoked on this worker thread. The reason for this arrangement is because the methods exposed by REngine are typically handled asynchronously by distributed services. When the distributed service reponds to REngine's methods, the worker thread will invoke the appropriate callback. In this way the main thread is not blocked.</p>
<p >If you use multiple threads and mutexes in your application space, it is possible to deadlock, as R | API also uses mutexes internally. Generally, the Rithmic APIs will lock upon entry into an REngine method, as well as prior to invoking a user-defined callback. You can use the very mutex R | API uses by calling REngine::lock() and REngine::unlock() to avoid these deadlock situations preserving the order of the lock() calls in each thread.</p>
<h2><a class="anchor" id="pg_threads_dotnet"></a>
Threads In .NET API</h2>
<p >The .NET version of the Rithmic APIs creates multiple threads. Each persistent network connection will have an input thread as well as an output thread. There are other administrative threads which may also be created. The .NET APIs do not expose REngine::lock() and REngine::unlock() methods because thread management is done differently than in the C++ APIs.</p>
<hr  />
<h1><a class="anchor" id="pg_errors"></a>
Error Handling Conventions</h1>
<h2><a class="anchor" id="pg_error_codes"></a>
Error Codes</h2>
<p >All Rithmic APIs make use of the same set of integer error codes to convey information about error conditions. Rithmic APIs also make use of these same exception classes internally.</p>
<p >In C++, the set of error codes are defined in the RApi.h header file, starting with API_OK.</p>
<h2><a class="anchor" id="pg_exception_classes"></a>
Exception Classes</h2>
<p >The exception class is <a class="el" href="classOmneException.html" title="Exception class used by the RApi.">OmneException</a>. Error codes can be retrieved from exceptions using <a class="el" href="classOmneException.html#a8303a48112ee9f2d27446d5b5081689c">OmneException.getErrorCode()</a>.</p>
<h2><a class="anchor" id="pg_aicode_out_param"></a>
The 'aiCode' Out Parameter (C++ only)</h2>
<p >All C++ Rithmic API methods provide a return value (OK or NOT_OK, defined in RApi.h), where NOT_OK indicates an error condition. When an error is encountered, the aiCode 'out' parameter is set with the value of the appropriate error code.</p>
<h2><a class="anchor" id="pg_error_why"></a>
Why And Where Errors Might Occur</h2>
<p >Typically, an 'action' object such as REngine, requests services from the network, resulting in a callback method being invoked to convey the response. Errors can occur :</p>
<ul>
<li>Within the requesting method as it tries to form the request and send it to the infrastructure. In this case, the error will result in an error code returned directly from the method being called.</li>
</ul>
<ul>
<li>Within the infrastructure as it tries to service the request. In this case, the error code will be conveyed via the standard callback associated with the originating method and possibly RCallbacks::Alert(), depending on the severity of the error. The 'Info' classes have an iRpCode field when they need to convey an error status.</li>
</ul>
<ul>
<li>Within the API as it processes the response and invokes the appropriate callback. This case is similar to conveying errors encountered in the infrastructre. The error code will be conveyed via the standard callback associated with the originating method and possibly RCallbacks::Alert(), depending on the severity of the error.</li>
</ul>
<p>Constructors and destructors (caution when using with STL) may throw exceptions also.</p>
<p >Native exceptions being thrown from a Rithmic API method indicate unhandled exceptions.</p>
<h2><a class="anchor" id="pg_error_examples"></a>
Examples Of Errors</h2>
<ul>
<li>
<p class="startli">An example of an error encountered locally in the REngine is if one attempts to subscribe to market data without being logged in. The error code returned would be 11, or 'no handle', indicating that there was no handle for the market data connection.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Alerts are fired if a more serious error has been reported by R | Trade Execution Platform. An example would be an error code of 14, or 'unknown request'. This error code indicates that the service being requested is down or off-line.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">When an expected error is returned by R | Trade Execution Platform, the response code of the 'Info' instance, which is passed to the callback method, will contain the corresponding error code. An example of this case would be if REngine::getRefData() were called for an invalid instrument. RCallbacks::RefData() would be called where RefDataInfo's response code would contain a value of 7, or 'no data'. In other words, R | Trade Execution Platform has no data on the instrument being referenced.</p>
<p class="endli">When an unexpected error is returned by R | Trade Execution Platform, an Alert is raised by RCallbacks::Alert(). The AlertInfo instance will contain information about the error. </p>
</li>
</ul>
<h2><a class="anchor" id="pg_errors_in_user_callbacks"></a>
Error Handling In User Implemented Callbacks</h2>
<p >When implementing a callback method in C++, the expectation is that the callback will return (OK), or return (NOT_OK) with the value of *aiCode set to API_IGNORED. If the callback method returns NOT_OK with a *aiCode value that is not API_IGNORED, the error will be interpretted as a grievous error and cause the connection associated with the callback to be broken. This should only be done when actually encountering a grievous error.</p>
<hr  />
<h1><a class="anchor" id="pg_basic_steps"></a>
Basic Steps of a Program that Incorporates R | API</h1>
<p >The following list presents the basic steps that a program that incorporates R | API must perform: </p><ul>
<li>Create an instance of AdmCallbacks. This implies that you have to define your own class, since AdmCallbacks is abstract. </li>
<li>Create and populate an instance of REngineParams. This set of parameters contains the configuration information needed to instantiate the REngine. Some of the configuration information will be retrieved from the environment (REngineParams::envp). Actual configuration values will be provided by the Rithmic operations team and may be specified in a configuration file (such as "uat_connection_params.txt") in your download directory. The naming conventions used in the operations document will loosely match the names in R | API interface. </li>
<li>Create an instance of the REngine, using the AdmCallbacks and REngineParams from above. The reason you need the AdmCallbacks is because you can receive administrative alerts without being logged in. </li>
<li>Create an instance of RCallbacks. Again, because it is an abstract class, you must derive your own subclass and implement it. Implementing all callbacks forces the user to explicitly handle or ignore the available callbacks. </li>
<li>Log in using REngine::login(). The methods invoked on the RCallbacks instance passed into the login call will correspond to this login session. </li>
<li>Wait for updates on the login status by examining the RCallbacks::Alert() callback. </li>
<li>If the login completes for all connect points, the program will be able to access the services of R | Trade Execution Platform. If any of the logins fail for any of the connect points, R | API will automatically log out of all connect points. In other words, each connect point has its own authentication handshake, and if one fails, they all fail. </li>
<li>Assuming a successful login, invoke methods on REngine, process responses in RCallbacks as necessary. </li>
<li>Logout. Note that REngine::logout() will automatically be called in the REngine destructor so this step is optional if you intend on destroying the REngine instance immediately. However, if you call REngine::logout() yourself, you can log back into R | Trade Execution Platform using the same instance of the REngine, but perhaps with different credentials. </li>
<li>Destroy the RCallbacks instance. You should not destroy the callbacks instance before logging out, as any of its methods may be called until the logout is complete. </li>
<li>Destroy the REngine instance. </li>
<li>Destroy the AdmCallbacks instance.</li>
</ul>
<hr  />
<h1><a class="anchor" id="pg_bug_reports"></a>
Feedback And Bug Reports</h1>
<p >We are always interested in hearing feedback regarding the API. This ranges from feature requests to bug reports to typos in the documentation.</p>
<hr  />
<h1><a class="anchor" id="pg_contact_info"></a>
Contact Info</h1>
<p >We can be reached at <a href="#" onclick="location.href='mai'+'lto:'+'rap'+'i@'+'rit'+'hm'+'ic.'+'co'+'m'; return false;">rapi@<span class="obfuscator">.nosp@m.</span>rith<span class="obfuscator">.nosp@m.</span>mic.c<span class="obfuscator">.nosp@m.</span>om</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Sep 16 2024 15:13:15 for R | API+ by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
